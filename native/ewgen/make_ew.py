from __future__ import print_function

import datetime
import os
from pathlib import Path
from typing import Optional, List, Tuple, Callable
from pycparser import c_ast, parse_file, c_generator
from pycparser.c_ast import FuncDecl, TypeDecl, ParamList, Typedef, Enum, Struct, \
    IdentifierType, PtrDecl


class FixedCGenerator(c_generator.CGenerator):

    def __init__(self):
        super().__init__()

    def visit_IdentifierType(self, node):
        if node.names == ["_Bool"]:
            return "bool"
        else:
            return super().visit_IdentifierType(node)


generator = FixedCGenerator()


class PrototypeCollector(c_ast.NodeVisitor):
    protos: List[str] = []
    names: List[Tuple[str, str]] = []
    predicate: Callable[[str], bool]
    prefix: str

    def __init__(self, prefix, predicate):
        self.prefix = prefix
        self.predicate = predicate

    def visit_Typedef(self, node: Typedef):
        if not self.predicate(node.name):
            return
        if isinstance(node.type, (Enum, Struct, PtrDecl)):
            self.protos.append(generator.visit(node))
        elif isinstance(node.type, TypeDecl) and isinstance(node.type.type,
                                                            (Enum, Struct, IdentifierType)):
            self.protos.append(generator.visit(node))

        else:
            raise Exception(f"Cannot do {generator.visit(node)}, ast= \n{node.type}")

    def visit_FuncDecl(self, node: FuncDecl):
        tpe: TypeDecl = node.type
        params: Optional[ParamList] = node.args
        ps = ", ".join(map(lambda d: generator.visit(d), [] if params is None else params.params))
        self.protos.append(
            f"typedef {generator.visit(tpe.type)} {self.prefix}_{tpe.declname}({ps})")
        self.names.append((f"{self.prefix}_{tpe.declname}", tpe.declname))


def mkStmts(xs: List[str]) -> str:
    return "\n".join(map(lambda x: x + ";", xs))


def generate_ew(name: str, predicate: Callable[[str], bool], *headers: str) -> (str, str):
    # Note that cpp is used. Provide a path to your own cpp or
    # make sure one exists in PATH.

    protos: List[str] = []
    names: List[(str, str)] = []

    for h in headers:
        if not os.path.exists(h):
            raise Exception(f"Header file {h} not found")
        ast = parse_file(h, use_cpp=True, cpp_args=r'-Iutils/fake_libc_include')
        v = PrototypeCollector(name, predicate)
        v.visit(ast)
        protos += v.protos
        names += v.names

    autogen_notice = "// This file is autogenerated with the following input:\n" + \
                     "\n".join(list(map(lambda x: f"// {x}", headers))) + "\n" + \
                     f"// using {os.path.basename(__file__)} at {datetime.datetime.now()}"

    header = f"""\
#pragma once

{autogen_notice}

#include <stddef.h>
#include <stdint.h>
#ifndef __cplusplus
#include <stdbool.h>   
#endif

#ifdef __cplusplus
extern "C" {{
#endif
    
typedef enum {{
  {name.upper()}_SUCCESS = 0,
  {name.upper()}_ALREADY_OPENED = 1,
  {name.upper()}_OPEN_FAILED= 1,
}} {name}_status_t;

void {name}_close(void);

{name}_status_t {name}_open(const char* path);

{mkStmts(protos)}

{mkStmts(list(map(lambda x: f"extern {x[0]}* {x[1]}", names)))}

#ifdef __cplusplus
}}
#endif
     
"""

    resolve_symbols = map(
        lambda x: f"  {x[1]} = ({x[0]}*) _dynamic_library_find({name}_lib, \"{x[1]}\")",
        names)

    impl = f"""\
#include "{name}.h"

{autogen_notice}

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#define VC_EXTRALEAN
#include <windows.h>

typedef HMODULE DynamicLibrary;
#define _dynamic_library_open(path)         LoadLibraryA(path)
#define _dynamic_library_close(lib)         FreeLibrary(lib)
#define _dynamic_library_find(lib, symbol)  GetProcAddress(lib, symbol)
#else
#include <dlfcn.h>

typedef void* DynamicLibrary;
#define _dynamic_library_open(path)         dlopen(path, RTLD_NOW)
#define _dynamic_library_close(lib)         dlclose(lib)
#define _dynamic_library_find(lib, symbol)  dlsym(lib, symbol)
#endif

static DynamicLibrary {name}_lib;

void {name}_close(void) {{
  if ({name}_lib) {{
    _dynamic_library_close({name}_lib);
    {name}_lib = NULL;
  }}
}}

{name}_status_t {name}_open(const char* path) {{
  if ({name}_lib) {{
    return {name.upper()}_ALREADY_OPENED;
  }}
  {name}_lib = _dynamic_library_open(path);
  if(!{name}_lib){{
    return {name.upper()}_OPEN_FAILED;
  }}
  
{mkStmts(list(resolve_symbols))}
  
  return {name.upper()}_SUCCESS;
}}

{mkStmts(list(map(lambda x: f"{x[0]}* {x[1]}", names)))}

"""

    return header, impl


def write(path: Path, content: str):
    path = path.absolute().resolve()
    path.parent.mkdir(exist_ok=True, parents=True)
    with open(path, 'w') as file:
        file.truncate()
        file.write(content)


def generateHSA(include_dir: Path):
    (header, impl) = generate_ew("hsaew",
                                 lambda s: s.startswith(("hsa_", "HSA_")),
                                 str(include_dir / "hsa_ext_amd.h"))
    write(Path("../runtime/thirdparty/hsaew/src/hsaew.c"), impl)
    write(Path("../runtime/thirdparty/hsaew/include/hsaew.h"), header)


if __name__ == "__main__":
    generateHSA(Path("/opt/rocm/hsa/include/hsa"))
